-- SEMANA 01

HTML, CSS e JS
    - HTML é a estrutura e semântica da página (o esqueleto)
        - O conteúdo é definido por blocos de construção
    - CSS é o visual
        - É uma linguagem de estilo usada para descrever apresentação de um documento escrito em HTML
    - JS é responsável pelo comportamento da página
    - Ajax é o JS que faz requisição para um serviço BE
    - DOM é o HTML renderizado na tela

Browser engines: quais navegadores vamos testar, se vamos testar em múltiplos browsers
    - Chromium: a que mais tem usuários, como chrome, microsfot edge, etc
    - Gecko: da mozilla, utilizado pelo firefox
    - WebKit: utilizado pelo safari
    - Tem outros, mas são menos usados
        - IE usava trident, mas migrou para o chromium quando foi para o edge
Estilos de design
    - Responsivo: ela se ajusta ao espaço disponível para exibição da tela, a partir da marcação de tamanho
    - Adaptativo: o design não se altera quando se diminui/aumenta a exibição da tela, mas ela será modificada ao atualizar/recarregar a página
Elementos de uma WebApp
    - Componentes
    - Páginas: um conjunto de componentes
    - Layouts (cabeçalho/rodapé): acompanha a página independente de onde estiver
        - Evita duplicação de teste
    - Rotas: URLs das páginas
    - Estados: status dos componentes (se está selecionado, não selecionado, mouse over, etc), geralmente usado em teste de componente, mas importante para e2e
    - Comunicação com API/BE
    - Assets: todos os arquivos de mídia na aplicação (ícone, imagem, fontes, vídeo)
Eventos
    - Interações com a aplicação web:
        - Clique
        - Digitar
        - Passar sobre (hover)
        - Navegar pra cima/baixo (scroll)
Dados no browser
    - Armazenamento
        - Cookies
        - Storage
            - Sessão
            - Local

Automação de testes web
    - Três principais arquiteturas
        - Baseado no protocolo webdriver (Selenium, webdriver.io)
            - O webdriver age como um meio de campo entre o código e o navegador
            - Pro: suporte a diferentes browsers
            - Cons: como roda de forma externa ao browser, então dificulta acesso a funções internas da aplicação
        - Baseado no CDP (Chrome DevTools Protocol) (Puppeteer, playwright)
            - A comunicação é feita direto com o API do navegador
            - Costuma ter melhor performance
            - Usa websocket, então ele funciona quase que em tempo real
            - Pro: acesso a API dos navegadores
            - Cons: não está na W3C, o que demora a adesão da ferramenta pela comunidade
        - JS no navegador (Cypress)
            - Cons: é um desafio tornar compatível com múltiplos browsers
            - Ele roda direto no navegador, sem API ou webdriver
    - Novo protocolo: webdriver bidi
        - Usa comunicação websocket
        - Segue padrão da W3C
        - Tipo webdriver 2.0

Seletores
    - Seletor é um filtro
    - CSS Selector é o filtro num arquivo HTML
        - As tags (button, table, input)
        - Classe
        - ID (#botao-login)
        - Atributo ([placeholder="Entrar"], [id="test"], [class="inputtext"], etc)
        - Universais
        - Dedicados a testes ([test-id="tst-login-button"])
    - XPath é o filtro num arquivo XML, e a página HTML é um XML padronizado
        - Possibilidade de navegação a partir de uma âncora (axes), muito usado quando a página não está bem estruturada
        - XPath tem funções também, e é possível a partir dela usar text() e contains()
            - O cy.contains() faz o mesmo do contains()
        - XPath é MUITO usado na automação mobile, pois não tem a estrutura do CSS Selector
        - Cons: A velocidade de processamento é um pouco menor que o do CSS Selector, mas a diferença é quase irrelevante
    - Seletores contextuais
        - Tem no XPath naturalmente
        - Playwright e Cypress permitem que possamos navegar pela árvore de elementos sem uso do XPath

Apesar da pirâmide de testes, para aplicações web, é muito comum se usar o modelo do troféu de testes
    ------ e2e -------
    --- integration --
    ----- unit -------
    ------ static ----
    - O Cypress é muito usado para e2e, simulando ações do usuário de ponta a ponta, e integração

Existem dois tipos de esperas:
    - Implícita
        - Esperas relacionadas ao tempo, onde a ferramenta aguardará o tempo máximo para executar o comando
        - Configuração global da ferramenta ou do comando, que pode ser definido previamente
    - Explícita
        - Condição para a ferramenta aguardar antes de prosseguir com a ação
    - Automática
        - Alguns comandos já possuem espera automática, como click, get, check

Screenshots
    - Screenshots podem ser gerados quando há falha, a cada passo ou durante o teste
    - O uso de screeshots pode ser feito para validar ou verificar onde houve o erro

Teste headless
    - Execução do teste no navegador sem que ele abra
    - Utilizado durante execução na pipeline

-- SEMANA 02

Refatoração
    - Hooks: coisas que quero que sejam executadas antes ou depois dos testes
        - before -> 1x antes de todos os testes
        - beforeEach -> antes de cada teste
        - after -> 1x depois de todos os testes
        - afterEach -> depois de cada teste

Debugging e análise de falhas
    - Logs
        - Logs nos testes com cy.log
        - Logs no terminal
        - Logs no navegador (console.log)
        - É possível salvar o resultado do modo headless num arquivo txt
            - npx cyress run > nome-arquivo.txt
    - Screenshots e vídeos
        - cy.screeshot
        - config pra gerar vídeo
        - screeshots das falhas
    - StackTrace
    - Principais motivos de falha
        - Element not found
        - Assertion error
        - Command timeout
        - Cannot read property of undefined
        - cy.visit failed

Organização e separação de responsabilidades
    - Fixtures: recurso para colocar funcionalidades separadamente e reusá-la nos scripts, havendo separação de dados e lógica dos testes
        - Costuma se colocar também arquivos a serem usados pelos testes
        - Pode ser chamado de data ou similar em outros projetos, caso não haja fixture
        - Sobre cy.fixture: obter uma informação usando esse comando e usá-la posteriormente
            - O problema disso que se mudar de ferramenta, isso precisará ser reescrito
            - Recomendado o uso quando há uso de imagens ou documentos
    - Dados hardcoded: dados fixos no código, sem geração dinâmica
    - Dados externos

Funções utilitárias e auxiliares
    - Posso usar para delegar lógicas a essas funções e focar apenas nos testes
    - Eles ficam na pasta de support na estrutura do cypress
    - Podemos usar o faker para gerar dados dinâmicos e chamar nos nossos testes

Módulos e páginas
    - O mais comum da automação web é que dividamos os scripts em módulos ou páginas ou funcionalidades
    - Usando o automation exercise como exemplo:
        - menu (header/footer)
            - navegar para um menu específico
        - carrinho
            - proceder para o checkout
            - remover produto
            - adicionar/diminuir quantidade
            - navegar para detalhe do produto que está presente no carrinho
        - login
            - login com sucesso
            - preencher form de cadastro
        - cadastro
            - preencher o form de cadastro completo
        - contato
            - preencher form de contato
            - fazer upload de arquivo
        - produtos
            - pesquisar produto
            - filtrar produto
            - adicionar produto no carrinho
            - ver detalhe do produto
    - Num teste e2e, eu posso passar por vários desses módulos e mesclar ações
        - Nesse caso, faz sentido dividir por módulos
        - Facilita o reuso do código, chamando em diversos cenários
        - exemplo de fluxo:
            1. login -> preenchi form de login
            2. produto -> filtrei por categoria
            3. produto -> adicionei no carrinho um produto
            4. carrinho -> prossegui para o checkout

            1. login -> preenchi form de login
            2. produto -> pesquisei por um produto
            3. produto -> adicionei no carrinho um produto
            4. carrinho -> prossegui para o checkout
        - Antigamente, a galera usava muito POM como organização do projeto
            - Hoje em dia se pensa em modularizar apenas o necessário
        - Podemos organizar com:
            - function
            - comandos customizados
            - classes
    - Não confundir módulos com POM
        - App actions vale ser usado quando há contato com o código fonte da aplicação
        - Quando não há contato, podemos usar modularização
    - A convenção geralmente é de que ações do teste a gente abstrai (modularização), asserções dos teste, a gente mantém no arquivo de teste

Comandos customizados
    - Serve para expandir a api da ferramente, sendo acessível através do cy 
    - O porém é que tudo ficaria nesse arquivo, e a medida que o projeto for expandindo, ele pode se tornar custoso de entender e manter
    - Além de que pode confundir com comandos nativos para cypress
    - Nem tudo precisa ser um comando customizado, modularização pode ser uma melhor alternativa

Relatórios
    - Pode passar a visão resumida dos resultados
    - Pode ser gerado em txt, json ou xml
    - Uma ideia é usar o cypress-mochawesome-report

Janelas e drag and drop
    - Janelas/abas são muito usadas para efetuar recursos ou redirecionar para sites externos
    - Drag and drop é a ação de arrastar um elemento de uma área para outra, o Trello usa muito (o jira também tem essa funcionalidade)
    - O cypress lida com isso através do trigger, que dispara um evento do dom
    - Para múltiplas janelas, a característica dela é o atributo "target"
        - No selenium tem o switchTo para trabalhar com uma janela aberta
        - No cypress, a gente usa invoke para executar funções no navegador, incluindo remover atributo do html
            - Para voltar a janela anterior, a gente usa cy.go('back')
    - Para drag and drop, a gente usa o data transfer, mas tem plugins para isso também, como cypress-drag-drop
        - No cypress, a gente cria uma instâcia do data transfer, chama a função de trigger para o atributo e passa o data transfer como valor

Integração na pipeline
    - O mesmo feito anteriormente